using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Text.Encoding;
using System.Text.RegularExpressions;

using Nemerle.IO;
using Nemerle.Utility;


namespace httplib {

//------------------------------------------------------------------------------
// Array

public class Array {

    arr: array[string];

    public this(data: array[string]) {
        arr = data;
    }

    public Item[index: int]: string {
        get { arr[index]; }
    }

    public Length: int {
        get { arr.Length; }
    }

    public forEach(lambda: string -> void): void {
        foreach(v in arr) {
            lambda(v);
        }
    }

    public toSystemType(): array[string] {
        arr;
    }
}


//------------------------------------------------------------------------------
// HashTable

public class HashTable {

    nvc: NameValueCollection;

    public this() {
        nvc = NameValueCollection();
    }

    public this(data: NameValueCollection) {
        nvc = data;
    }

    public Item[key: string]: string {
        get { nvc[key]; }
        set { nvc[key] = value; }
    }

    public Keys: array[string] {
        get { nvc.AllKeys; }
    }

    public forEach(lambda: string * string -> void): void {
        foreach(k in Keys) {
            lambda(k, Item[k]);
        }
    }

    public toSystemType(): NameValueCollection {
        nvc;
    }
}


//------------------------------------------------------------------------------
// Request

public class Request {

    [Accessor] http_method: string;
    [Accessor] url: Uri;
    [Accessor] raw_url: string;
    [Accessor] query_string: HashTable;
    [Accessor] headers: HashTable;
    [Accessor] path: Array;
    [Accessor] raw_path: string;
    [Accessor] extension: string;

    public this(req: HttpListenerRequest) {

        http_method = req.HttpMethod;
        url = req.Url;
        raw_url = req.RawUrl;
        query_string = HashTable(req.QueryString);
        headers = HashTable(req.Headers);
        path = makePathArray(RawUrl);
        raw_path = makeRawPath(Path);
        extension = makeExtension(Path);
    }

    /** convert a RawUrl -> path component Array
     *  "/a/b//c" -> [ "a", "b", "c" ]
     */
    makePathArray(rawUrl: string): Array {

        def path_only = rawUrl.Split(array['?'], StringSplitOptions.None);
        def path_section =
            if(path_only.Length > 0) {
                path_only[0]
            } else {
                rawUrl
            };
        def path_split = path_section.Split(
            array['/'], StringSplitOptions.RemoveEmptyEntries );

        Array(path_split);
    }

    makeExtension(path: Array, full: bool = false): string {

        def last_path =
            if(path.Length > 0) {
                path[path.Length - 1];
            } else {
                ""
            }
        def last_split = last_path.Split(
            array['.'], StringSplitOptions.None );

        if(last_split.Length > 1) {
            if(full) {
                def len = last_split.Length - 1;
                mutable tmp: array[string] = array(len);
                Array.Copy(last_split, 1, tmp, 0, len);
                String.Join(".", tmp)
            } else {
                last_split[last_split.Length - 1];
            }
        } else {
            ""
        }
    }

    makeRawPath(path: Array): string {
        String.Join("/", path.toSystemType());
    }
}


//------------------------------------------------------------------------------
// Response

public class Response {

    public ContentLength: long {
        get { response.ContentLength64 }
        set { response.ContentLength64 = value; }
    }

    public ContentType: string {
        get { response.ContentType }
        set { response.ContentType = value; }
    }


    public StatusCode: int {
        get { response.StatusCode }
        set { response.StatusCode = value; }
    }

    public StatusDescription: string {
        get { response.StatusDescription }
        set { response.StatusDescription = value; }
    }

    mutable response: HttpListenerResponse;
    mutable output: array[byte];

    public this(res: HttpListenerResponse, output_length = 1024) {

        response = res;
        output = array(output_length);
    }

    public append(params data: array[string]): void {
        appendArray(data);
    }

    public appendArray(data: array[string]): void {

        foreach(d in data) {
            def buffer = UTF8.GetBytes(d);
            writeToOutput(buffer);
        }
    }

    public appendBytes(data: array[byte]): void {
        writeToOutput(data);
    }

    writeToOutput(data: array[byte]): void {
        def new_length = ContentLength + data.Length;

        when(output.Length < new_length) {
            def _32 = output.Length * 3 / 2;
            def nl = if(_32 > new_length) { _32 } else { new_length :> int }
            Array.Resize(ref output, nl);
        }

        data.CopyTo(output, ContentLength);
        ContentLength = new_length;
    }

    internal complete(): void {
        def os = response.OutputStream;
        os.Write(output, 0, ContentLength :> int);
        os.Close();
    }
}


//------------------------------------------------------------------------------
// ServerConfiguration

[Record]
public class ServerConfiguration {

    [Accessor(flags = WantSetter)] mutable prefixes: array[string];
    [Accessor(flags = WantSetter)] mutable output_length: int;
    [Accessor(flags = WantSetter)] mutable root: string;
    [Accessor(flags = WantSetter)] mutable file_chunk_length: int;
}



//------------------------------------------------------------------------------
// Route

public class Route {

    [Accessor] input: string;
    regex: Regex;
    mutable captures: array[string] = array(0);

    public this(path: string) {

        def regex_string = Regex.Replace(path, @"{(\w+)}", m => {

            def v: string = m.Groups[1].ToString();
            def e = this.captures.Length;

            Array.Resize(ref this.captures, e + 1);
            this.captures[e] = v;

            @"(\w+)";
        });
        regex = Regex(regex_string);
        input = regex_string;
    }

//    static public @==(a: Route, b: Route): bool {
//        a.GetHashCode() == b.GetHashCode();
//    }

    public ismatch(path: string): bool {
        regex.IsMatch(path)
    }

    public domatch(path: string, lambda: HashTable * bool -> void): bool {

        mutable hash = HashTable();
        def result = regex.IsMatch(path);
        when(result) {
            def _ = regex.Replace(path, m => {
                for(mutable i = 1; i < m.Groups.Count; i++) {
                    def k = captures[i - 1];
                    def v = m.Groups[i].ToString();
                    hash[k] = v;
                }
                ""
            }, 100, 0);
        }
        lambda(hash, result);
        result;
    }
}


//------------------------------------------------------------------------------
// Server

public abstract class Server: IDisposable {

    public type Callback = HashTable * Request * Response -> void;

    [System.Flags]
    public enum State {
        | Neutral = 0x00
        | Running = 0x01
        | Closed = 0x02
    }

    [Accessor(Flags, flags = Protected)]
    [FlagAccessor(Running, flags = Protected | WantSetter)]
    [FlagAccessor(Closed, flags = Protected | WantSetter)]
    mutable state: State = State.Neutral;

    [Accessor(flags = Protected)]
    listener: HttpListener = HttpListener();

    [Accessor(flags = Protected)]
    configuration: ServerConfiguration;

    [Accessor(flags = Protected)]
    routes: Dictionary[string, Route * Callback] = Dictionary();

    // route("/a/b/c", r => { })
    public route(path: string, fn: Callback): void {
        def r = Route(path);
        def s = r.Input;
        print("route: '$(path)' added $(fn)\n");
        Routes.Add(s, (r, fn));
    }

    public this(config: ServerConfiguration) {
        configuration = config;

        foreach(p in Configuration.Prefixes) {
            print("Adding \"$p\"...\n");
            Listener.Prefixes.Add(p);
        }
        Listener.Start();
    }

    public Dispose(): void {
        shutdown();
    }

    protected override Finalize(): void {
        shutdown();
    }

    shutdown(): void {

        when(!Closed) {
            Listener.Close();
            Running = false;
            Closed = true;
        }
    }

    public update(): void {
        Running = true;
        def _ = Listener.BeginGetContext(
            AsyncCallback(listenerCallback), this);
    }

    static extensionToMimeType(ext: string): string {
        match(ext) {
            | "js" => "application/javascript"
            | "json" => "application/json"
            | "html" => "text/html"
            | "css" => "text/css"
            | "ttf" => "application/x-font-ttf"
            | "woff" => "application/x-font-woff"
            | "woff2" => "application/octet-stream"
            | _ => "text/plain"
        }
    }

    serveFile(path: string, contentType: string, response: Response): void {

        using(def reader = BinaryReader(File.Open(path, FileMode.Open))) {
            mutable continue = true;

            while(continue) {
                def data = reader.ReadBytes(Configuration.FileChunkLength);
                response.appendBytes(data);
                continue = (data.Length == Configuration.FileChunkLength);
            }
            response.ContentType = contentType;
        }
    }

    protected abstract callback(request: Request, response: Response): void;

    static listenerCallback(result: IAsyncResult): void {

        def server = result.AsyncState :> Server;
        def context = server.Listener.EndGetContext(result);
        def request = Request(context.Request);
        def config = server.Configuration;
        mutable response = Response(context.Response, config.OutputLength);

        def path = Path.Combine(config.Root, request.RawPath);
        def exists = File.Exists(path);

        print("Requesting: \"$(request.RawPath)\"...\n");

        mutable vars = HashTable();
        def cb = server.findCallback("/" + request.RawPath, out vars);
        if(cb != null) {
            cb(vars, request, response);
        } else if(exists) {
            server.serveFile(path, extensionToMimeType(request.Extension), response);
        } else {
            server.callback(request, response);
        }
        response.complete();
    }


    findCallback(path: string, vars: out HashTable): Callback {
        mutable result;
        exit: {
            foreach(r in Routes) {
                mutable route, fn;
                (route, fn) = r.Value;

                when(route.ismatch(path)) {
                    print("'$(path)' matches '$(route.Input)'...\n");
                    mutable v = HashTable();
                    def _ = route.domatch(path, (h, _r) => {
                        v = h;
                    });
                    result = fn;
                    vars = v;
                    exit();
                }
            }
        }
        result;
    }
}


} // namespace httplib
