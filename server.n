using System;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Text.Encoding;

using Nemerle.IO;
using Nemerle.Utility;


namespace httplib {

//------------------------------------------------------------------------------
// Array

public class Array {
    arr: array[string];

    public this(data: array[string]) {
        arr = data;
    }

    public Item[index: int]: string {
        get { arr[index]; }
    }

    public Length: int {
        get { arr.Length; }
    }

    public forEach(lambda: string  -> void): void {
        foreach(v in arr) {
            lambda(v);
        }
    }
}


//------------------------------------------------------------------------------
// HashTable

public class HashTable {

    nvc: NameValueCollection;


    public this(data: NameValueCollection) {
        nvc = data;
    }

    public Item[key: string]: string {
        get { nvc[key]; }
    }

    public Keys: array[string] {
        get { nvc.AllKeys; }
    }

    public forEach(lambda: string * string -> void): void {
        foreach(k in Keys) {
            lambda(k, Item[k]);
        }
    }
}


//------------------------------------------------------------------------------
// Request

public class Request {

    [Accessor] http_method: string;
    [Accessor] url: Uri;
    [Accessor] raw_url: string;
    [Accessor] query_string: HashTable;
    [Accessor] headers: HashTable;
    [Accessor] path: Array;
    [Accessor] extension: string;

    public this(req: HttpListenerRequest) {
        http_method = req.HttpMethod;
        url = req.Url;
        raw_url = req.RawUrl;
        query_string = HashTable(req.QueryString);
        headers = HashTable(req.Headers);
        path = makePathArray(RawUrl);
        extension = makeExtension(Path);
    }

    /** convert a RawUrl -> path component Array
     *  "/a/b//c" -> [ "a", "b", "c" ]
     */
    makePathArray(rawUrl: string): Array {

        def path_only = rawUrl.Split(array['?'], StringSplitOptions.None);
        def path_section =
            if(path_only.Length > 0) {
                path_only[0]
            } else {
                rawUrl
            };
        def path_split = path_section.Split(
            array['/'], StringSplitOptions.RemoveEmptyEntries );

        Array(path_split);
    }

    makeExtension(path: Array): string {
        def last_path =
            if(path.Length > 0) {
                path[path.Length - 1];
            } else {
                ""
            }
        def last_split = last_path.Split(
            array['.'], StringSplitOptions.None );

        if(last_split.Length > 1) {
            def len = last_split.Length - 1;
            mutable tmp: array[string] = array(len);
            Array.Copy(last_split, 1, tmp, 0, len);
            String.Join(".", tmp)
        } else {
            ""
        }
    }
}


//------------------------------------------------------------------------------
// Response

public class Response {

    [Accessor(flags = WantSetter)]
    mutable output_stream: Stream;

    [Accessor(flags = WantSetter)]
    mutable content_length: long;

    public this(res: HttpListenerResponse) {
        output_stream = res.OutputStream;
        content_length = res.ContentLength64;
    }

    public append(params data: array[string]): void {
        appendArray(data);
    }

    public appendArray(data: array[string]): void {
        foreach(d in data) {
            def buffer = UTF8.GetBytes(d);
            ContentLength += buffer.Length;
            OutputStream.Write(buffer, 0, buffer.Length);
        }
    }
}


//------------------------------------------------------------------------------
// Server

public abstract class Server: IDisposable {

    [System.Flags]
    public enum State {
        | Neutral = 0x00
        | Running = 0x01
    }


    [Accessor(Flags, flags = Protected)]
    [FlagAccessor(Running, flags = Protected | WantSetter)]
    mutable state: State = State.Neutral;

    [Accessor(flags = Protected)]
    listener: HttpListener = HttpListener();

    public this(params prf: array[string]) {

        foreach(p in prf) {
            print("Adding \"$p\"...\n");
            Listener.Prefixes.Add(p);
        }
        Listener.Start();
    }

    public Dispose(): void {

        Listener.Close();
        Running = false;
    }

    public update(): void {
        Running = true;
        def _ = Listener.BeginGetContext(
            AsyncCallback(listenerCallback), this);
    }

    protected abstract callback(request: Request, response: Response): void;

    static listenerCallback(result: IAsyncResult): void {

        def server = result.AsyncState :> Server;
        def context = server.Listener.EndGetContext(result);
        def request = Request(context.Request);
        mutable response = Response(context.Response);

        server.callback(request, response);
        response.OutputStream.Close();
    }
}


} // namespace httplib
