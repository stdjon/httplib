using System;
using System.Collections.Generic;
using System.Security.Cryptography;

using Nemerle.Extensions;

using httplib;


namespace forum {

// Security Token types
public enum STOK {
    | SECURE
    | INSECURE
    | TEMPORARY
}


// TODO: make this configurable
public module SecureTokenExtensions {

    // Token Length (bytes)
    public Length(this tok: STOK): int {
        match(tok) {
            | SECURE => 60
            | INSECURE => 40
            | TEMPORARY => 20
        }
    }

    // Token duration (minutes)
    public Duration(this tok: STOK): int {
        match(tok) {
            | SECURE => 30 * 24 * 60
            | INSECURE => 30
            | TEMPORARY => 1
        }
    }

    public IsSecure(this tok: STOK): bool {
        | SECURE => true
        | _ => false
    }
}


public class ForumServer: Server {

    Rng: RNGCryptoServiceProvider { get; private set; }

    public this(path: string) {
        base(path);

        Rng = RNGCryptoServiceProvider();

        route(HTTP.GET, "/", indexResponse);
        route(HTTP.GET, "/index", BaseHandler.Factory("index.nyml"));

        route(HTTP.GET, "/nav-{{action}}", NavHandler.Factory(HTTP.GET));
        route(HTTP.POST, "/nav-{{action}}", NavHandler.Factory(HTTP.POST));

        route(HTTP.POST, "/tok-{{action}}", tokPostResponse);
        route(HTTP.GET, "/signup", signupResponse);
        route(HTTP.POST, "/signup-submit", signupSubmitResponse);
        route(HTTP.GET, "/is-user", isUserResponse);

        route([
            (HTTP.GET, "/u"),
            (HTTP.GET, "/u/{{num:[0-9]+}}")], usersRedirectPageResponse);
        route(HTTP.GET, "/u/{{from:[0-9]+}}-{{to:[0-9]+}}", usersPageResponse);
        route(HTTP.GET, "/u/{{user:[A-Za-z_].*}}", userPageResponse);

        route(HTTP.GET, "/p/{{num:[0-9]+}}", postPageResponse);

        route([
            (HTTP.GET, "/th/{{id:[0-9]+}}"),
            (HTTP.GET, "/th/{{id:[0-9]+}}/{{from:[0-9]+}}-{{to:[0-9]+}}")], threadPageResponse);
    }

    public indexResponse(
        _context: Context, request: Request, response: Response): void {

        def signout = request.QueryString["signout"];

        def cookies = request.Cookies;
        def isession =
            (signout == null && cookies != null) ? cookies["_isession"] : null;

        when(signout != null) {
            response.Cookies.expire("_isession", COOKIE.HTTP_ONLY);
        }

        def data = PageData() <- [
            "DefaultSecurePrefix" = DefaultSecurePrefix,
            "DefaultInsecurePrefix" = DefaultInsecurePrefix,
            "DefaultPrefix" = getDefaultPrefix(request),
        ];
        if(isession != null) {
            def id = getUserIdFromSessionToken(STOK.INSECURE, isession);
            def name = getUserName(id :> uint);
            _ = data <- [
                "User" = name,
            ];
        } else {
            def (_ok, t, _x) = registerSessionToken(STOK.TEMPORARY, 0);
            _ = data <- [
                "TempToken" = t,
            ];
        }
        response.append(renderPage("index.nyml", data));
        response.Status = (200, "OK");
    }

    public tokPostResponse(
        context: Context, request: Request, response: Response): void {

        def action = context.Vars["action"];
        def lambda = match(action) {
            | "set" => tokSetResponse
            | "check" => tokCheckResponse
            | _ => methodNotAllowedResponse
        }
        lambda(context, request, response);
    }

    public signupResponse(
        _context: Context, request: Request, response: Response): void {

        if(request.IsSecure) {
            def cookies = request.Cookies;
            def u = cookies ? cookies["_u"] : null;
            mutable user = !String.IsNullOrEmpty(u) ? u : null;

            def data = PageData() <- [
                "User" = user,
                "DefaultSecurePrefix" = DefaultSecurePrefix,
                "DefaultInsecurePrefix" = DefaultInsecurePrefix,
            ];

            response.append(renderPage("signup.nyml", data));
            response.Cookies.expire("_u", COOKIE.SECURE_HTTP_ONLY);
            response.Status = (200, "OK");
        } else {
            response.append("<html><body><h1>Forbidden!</h1></body></html>");
            response.Status = (403, "Forbidden");
        }
    }

    public signupSubmitResponse(
        context: Context, request: Request, response: Response): void {

        if(request.IsSecure) {
            def user = context.Vars["user"];
            def password = context.Vars["password"];
            def confirm = context.Vars["confirm"];
            def email = context.Vars["email"];


            mutable command1 = Database.createCommand("SELECT Name FROM Users "
                "WHERE Name = @Name") <- [ "@Name" = user ];

            mutable command2 = Database.createCommand("SELECT Email FROM Auth "
                "WHERE Email = @Email") <- [ "@Email" =  email ];

            def test1 = command1.executeScalar() :> string;
            def test2 = command2.executeScalar() :> string;

            if(test1 != null || test2 != null || password != confirm) {
                // TODO: also repeat the validation checks from client side
                //   user length (3-25), chars
                //   password length (8-60), chars

                // error with user data.
                // (need a more considered response though...)
                response.append("<html><body><h1>Bad Request!</h1></body></html>");
                response.Status = (400, "Bad Request");
            } else {
                def auth = getModuleInterface.[mod.IPbkdf2Auth]();
                mutable token = null;
                mutable expiry;

                if(auth != null) {
                    def now = DateTime.Now.ToUniversalTime();

                    Database.withTransaction(_ => {
                        mutable command3 = Database.createCommand(
                            "INSERT INTO Users(Name, Level, Points, JoinDate) "
                                "VALUES (@Name, 0, 0, @JoinDate)") <- [
                            "@Name" = user,
                            "@JoinDate" = now,
                        ];
                        _ = command3.executeNonQuery();

                        mutable command4 = Database.createCommand(
                            "SELECT Id FROM Users WHERE "
                                "Name = @Name") <- [ "@Name" = user ];

                        def id = command4.executeScalar() :> uint;

                        def record = auth.createPasswordRecord(password);

                        mutable command5 = Database.createCommand(
                            "INSERT INTO Auth(UserId, PwRecord, Email) "
                                "VALUES (@UserId, @PwRecord, @Email)") <- [
                            "@UserId" = id,
                            "@PwRecord" = record,
                            "@Email" = email,
                        ];
                        _ = command5.executeNonQuery();

                        def (ok, t, x) = registerSessionToken(STOK.SECURE, id);
                        when(ok) {
                            token = t;
                            expiry = x;
                        }
                    });

                    response.Cookies.add(
                        "_session", token, expiry, COOKIE.SECURE_HTTP_ONLY);
                    response["Location"] = DefaultInsecurePrefix + "/";
                    response.Status = (303, "See Other");

                } else {
                   internalServerErrorResponse(context, request, response);
                    Log.w("IPbkdf2Auth module was not found.");
                }
            }
        } else {
            response.append("<html><body><h1>Forbidden!</h1></body></html>");
            response.Status = (403, "Forbidden");
        }
    }

    public isUserResponse(
        _context: Context, request: Request, response: Response): void {

        def u = request.QueryString["u"];
        def e = request.QueryString["e"];
        mutable ok = null;
        if(!String.IsNullOrEmpty(u)) {
            mutable command = Database.createCommand(
                "SELECT Name FROM Users WHERE Name = @Name") <- [
                    "@Name" = u,
                ];
            ok = command.executeScalar() :> string;
        }
        else when(!String.IsNullOrEmpty(e)) {
            mutable command = Database.createCommand(
                "SELECT Email FROM Auth WHERE Email = @Email") <- [
                    "@Email" = e,
                ];
            ok = command.executeScalar() :> string;
        }
        response.Status = ok ? (200, "OK") : (404, "Not Found");
    }

    public usersRedirectPageResponse(
        context: Context, request: Request, response: Response): void {

        def num = context.Vars["num"];
        def from = !String.IsNullOrEmpty(num) ? Int32.Parse(num) : 1;
        def to = from + 24; //TODO: configurable?

        response["Location"] = $"$(getDefaultPrefix(request))/u/$from-$to";
        response.Status = (303, "See Other");
    }

    public usersPageResponse(
        context: Context, request: Request, response: Response): void {

        def from = Int32.Parse(context.Vars["from"]);
        def to = Int32.Parse(context.Vars["to"]);
        def dist = to + 1 - from;
        mutable users: PageDataArray = array(dist);
        mutable i = 0;

        def command = Database.createCommand(
            "SELECT Name, Level, Points, Motto FROM Users "
                "ORDER BY Name LIMIT @From, @To") <- [
                "@From" = from,
                "@To" = to,
            ];

        using(reader = command.executeReader()) {
            while(reader.Read() && i < dist) {
                def u = reader.GetValue.[string]("Name");
                when(u != null) {
                    def points = reader.GetValue.[int?]("Points", 0);
                    def level = reader.GetValue.[uint?]("Level", 0);
                    def motto = reader.GetValue("Motto", "");
                    users[i] = PageData() <- [
                        "Num" = (from + i).ToString(),
                        "Name" = u,
                        "Points" = points.ToString(),
                        "Level" = level.ToString(),
                        "Motto" = motto,
                    ];
                    i++;
                }
            }
        }

        when(i < dist) {
            Array.Resize(ref users, i);
        }

        def prf = getDefaultPrefix(request);
        mutable prev = null;
        mutable next = null;

        Log.d("from = {0} > 1 {1}", from, from > 1);
        when(from > 1) {
            def pf = Math.Max(1, from - dist);
            def pt = pf + dist - 1;
            prev = $"$prf/u/$pf-$pt";
        }
        Log.d("prev = {0}", prev);

        Log.d("to = {0} < {1} {2}", to, getUserCount(), to < getUserCount());
        when(to < getUserCount()) {
            def nf = from + dist;
            def nt = nf + dist - 1;
            next = $"$prf/u/$nf-$nt";
        }
        Log.d("next = {0}", next);

        def data = PageData() <- [
            "DefaultSecurePrefix" = DefaultSecurePrefix,
            "DefaultInsecurePrefix" = DefaultInsecurePrefix,
            "DefaultPrefix" = getDefaultPrefix(request),
            "Users" = users,
            "Prev" = prev,
            "Next" = next,
        ];

        response.append(renderPage("users.nyml", data));
        response.Status = (200, "OK");
    }

    public userPageResponse(
        context: Context, request: Request, response: Response): void {

        def user = context.Vars["user"];

        def command = Database.createCommand(
            "SELECT Motto, Location, JoinDate, Points, Level FROM Users WHERE "
                "Name = @Name") <- [ "@Name" = user ];

        using(reader = command.executeReader()) {
            mutable data = PageData();
            when(reader.Read()) {

                def date = reader.GetValue.[DateTime?]("JoinDate");
                _ = data <- [
                    "User" = user,
                    "Motto" = reader.GetValue("Motto", ""),
                    "Location" = reader.GetValue("Location", ""),
                    "JoinDate" = date ? date.ToString() : "never",
                    "Points" = reader.GetValue.[int?]("Points", 0),
                    "Level" = reader.GetValue.[uint?]("Level", 0),
                ];
            }

            _ = data <- [
                "DefaultSecurePrefix" = DefaultSecurePrefix,
                "DefaultInsecurePrefix" = DefaultInsecurePrefix,
                "DefaultPrefix" = getDefaultPrefix(request),
            ];

            response.append(renderPage("user.nyml", data));
            response.Status = (200, "OK");
        }
    }

    public postPageResponse(
        context: Context, request: Request, response: Response): void {

        def pid = Int32.Parse(context.Vars["num"]);
        def command = Database.createCommand(
            "SELECT UserId, ThreadId, CreateDate, Points, Content FROM "
                "Posts WHERE Id = @Id") <- [ "@Id" = pid ];

        mutable uid;
        mutable thid;
        mutable date;
        mutable points;
        mutable content;
        mutable ok = false;
        mutable data = PageData() <- [
            "DefaultSecurePrefix" = DefaultSecurePrefix,
            "DefaultInsecurePrefix" = DefaultInsecurePrefix,
            "DefaultPrefix" = getDefaultPrefix(request),
        ];

        using(reader = command.executeReader()) {
            when(reader.Read()) {
                uid = reader.GetValue.[uint?]("UserId", 0);
                thid = reader.GetValue.[uint?]("ThreadId", 0);
                date = reader.GetValue.[DateTime?]("CreateDate");
                points = reader.GetValue.[int?]("Points", 0);
                content = reader.GetValue("Content");
                ok = true;
            }
        }

        when(ok) {
            def command2 = Database.createCommand(
                "SELECT Name from Users WHERE Id = @Id") <- [ "@Id" = uid ];
            def name = command2.executeScalar() :> string;

            def command3 = Database.createCommand(
                "SELECT Title from Threads WHERE Id = @Id") <- [ "@Id" = thid ];
            def title = command3.executeScalar() :> string;

            _ = data <- [
                "PostId" = pid,
                "User" = name,
                "Thread" = title,
                "ThreadId" = thid,
                "CreateDate" = date ? date.ToString() : "never",
                "Points" = points,
                "Content" = content,
            ];
        }

        response.append(renderPage("post.nyml", data));
        response.Status = (200, "OK");
    }

    public threadPageResponse(
        context: Context, request: Request, response: Response): void {

        def thid = Int32.Parse(context.Vars["id"]);
        def fr_st = context.Vars["from"];
        def from = !String.IsNullOrEmpty(fr_st) ? Int32.Parse(fr_st) : 1;
        def to_st = context.Vars["to"];
        def to = !String.IsNullOrEmpty(to_st) ? Int32.Parse(to_st) : (from + 49);  //TODO: configurable?
        def dist = to + 1 - from;

        def command = Database.createCommand(
            "SELECT Title, UserId, CategoryId, CreateDate, Colour FROM Threads "
                "WHERE Id = @Id") <- [ "@Id" = thid ];

        mutable data = PageData() <- [
            "DefaultSecurePrefix" = DefaultSecurePrefix,
            "DefaultInsecurePrefix" = DefaultInsecurePrefix,
            "DefaultPrefix" = getDefaultPrefix(request),
        ];
        mutable ok = false;
        mutable uid;
        using(reader = command.executeReader()) {
            when(reader.Read()) {
                uid = reader.GetValue.[uint?]("UserId", 0);
                _ = data <- [
                    "Title" = reader.GetValue("Title"),
                    "UserId" = uid,
                    "CategoryId" = reader.GetValue.[uint?]("CategoryId", 0),
                    "CreateDate" = reader.GetValue.[DateTime?]("CreateDate"),
                    "Colour" = reader.GetValue("Colour"),
                ];
                ok = true;
            }
        }
        when(uid != null) {
            _ = data <- [ "UserName" = getUserName(uid :> uint) ];
        }

        when(ok) {
            mutable posts: PageDataArray = array(dist);
            mutable i = 0;

            def command2 = Database.createCommand(
                "SELECT Id, UserId, Points, CreateDate, Content FROM Posts WHERE "
                    "ThreadId = @ThreadId ORDER BY CreateDate LIMIT @From, @To") <- [
                "@ThreadId" = thid,
                "@From" = from,
                "@To" = to
            ];

            using(reader = command2.executeReader()) {
                while(reader.Read() && i < dist) {
                    def id = reader.GetValue.[uint?]("Id", 0);
                    uid = reader.GetValue.[uint?]("UserId", 0);
                    def points = reader.GetValue.[int?]("Points", 0);
                    def date = reader.GetValue.[DateTime?]("CreateDate");
                    def content = reader.GetValue("Content");

                    posts[i] = PageData() <- [
                        "Number" = from + i,
                        "PostId" = id,
                        "UserId" = uid,
                        "Points" = points,
                        "CreateDate" = date,
                        "Content" = content,
                    ];
                    i++;
                }
            }
            when(i < dist) {
                Array.Resize(ref posts, i);
            }
            def limit = i;

            for(i = 0; i < limit; i++) {
                _ = posts[i] <- [
                    "UserName" = getUserName(posts[i]["UserId"] :> uint),
                ];
            }

            // Add a marker for every fifth post (1, 6, 11...)
            def marker_count = (limit + 4) / 5;
            def markers: PageDataArray = array(marker_count);
            for(i = 0; i < marker_count; i++) {
                markers[i] = PageData() <- [ "Mark" = (i * 5) + from ];
            }

            _ = data <- [
                "Posts" = posts,
                "Markers" = markers,
            ];
        }

        response.append(renderPage("thread.nyml", data));
        response.Status = (200, "OK");
    }

    public tokSetResponse(
        context: Context, request: Request, response: Response): void {

        if(request.IsSecure) {
            def t = context.Vars["t"];

            def tmp = getUserIdFromSessionToken(STOK.TEMPORARY, t);
            def chk = tmp ? (tmp :> uint == 0) : false;
            def cookies = request.Cookies;
            def session = cookies ? cookies["_session"] : null;
            def tmp2 = getUserIdFromSessionToken(STOK.SECURE, session);
            def id: uint = tmp2 ? (tmp2 :> uint) : 0;
            mutable ok = false;

            when(chk && id != 0) {
                def (ok2, t, _x) = registerSessionToken(STOK.TEMPORARY, id);
                when(ok2) {
                    response.append(t);
                    ok = true;
                }
            }
            if(ok) {
                response.Status = (200, "OK");
            } else {
                internalServerErrorResponse(context, request, response);
            }
        } else {
            response.Status = (403, "Forbidden");
        }
    }

    public tokCheckResponse(
        context: Context, request: Request, response: Response): void {

        def t = context.Vars["t"];
        def tmp = getUserIdFromSessionToken(STOK.TEMPORARY, t);
        def id: uint = tmp ? (tmp :> uint) : 0;
        mutable ok = false;

        when(id > 0) {
            def (ok2, t, x) = registerSessionToken(STOK.INSECURE, id);

            when(ok2) {
                response.Cookies.add(
                    "_isession", t, x, COOKIE.HTTP_ONLY);
                ok = true;
            }
        }

        if(ok) {
            response.Status = (200, "OK");
        } else {
            internalServerErrorResponse(context, request, response);
        }
    }

    protected override internalServerError(ex: Exception): void {
        Log.e("INTERNAL SERVER ERROR!\n{0}\n{1}",
            ex.Message, ex.GetExtendedStackTrace());
    }

    public getDefaultPrefix(request: Request): string {
        if(request.IsSecure) {
            DefaultSecurePrefix
        } else {
            DefaultInsecurePrefix
        }
    }

    public getUserCount(): int {
        def commmand = Database.createCommand("SELECT COUNT(Name) FROM Users");
        def ex = commmand.executeScalar() :> long;
        unchecked ex :> int;
    }

    public getPostCount(thread_id: uint): int {
        def commmand = Database.createCommand(
            "SELECT COUNT(Id) FROM Posts WHERE ThreadId = @ThreadId") <- [
                "@ThreadId" = thread_id,
            ];
        def ex = commmand.executeScalar() :> long;
        unchecked ex :> int;
    }

    public getUserName(user_id: uint): string {
        def commmand = Database.createCommand(
            "SELECT Name FROM Users WHERE Id = @Id") <- [ "@Id" = user_id ];
        commmand.executeScalar() :> string;
    }

    public getSessionToken(tok: STOK): string {
        def bytes = array(tok.Length());
        Rng.GetBytes(bytes);
        def result = Convert.ToBase64String(bytes);
        Log.t("result.Length = {0}", result.Length);
        result;
    }

    public compareSessionTokens(tok: STOK, a: string, b: string): bool {
        def ba = Convert.FromBase64String(a);
        def bb = Convert.FromBase64String(b);
        mutable cmp = a.Length ^ b.Length;
        for(mutable i = 0; i < tok.Length(); i++) {
            def ca = ba[i % a.Length];
            def cb = bb[i % b.Length];
            cmp |= ca ^ cb;
        }
        cmp == 0;
    }

    public registerSessionToken(tok: STOK, id: uint): bool * string * DateTime {
        def token = getSessionToken(tok);
        def expiry = DateTime.Now.
            AddMinutes(tok.Duration()).ToUniversalTime();

        mutable command = Database.createCommand(
            "INSERT INTO Sessions(UserId, Token, ExpiryTime, IsSecure) "
                "VALUES(@UserId, @Token, @ExpiryTime, @IsSecure)") <- [
            "@UserId" = id,
            "@Token" = token,
            "@ExpiryTime" = expiry,
            "@IsSecure" = tok.IsSecure(),
        ];
        def rows = command.executeNonQuery();
        (rows == 1, token, expiry);
    }

    public expireSessionTokens(): void {
        def now = DateTime.Now.ToUniversalTime();

        def command = Database.createCommand(
            "DELETE FROM Sessions WHERE (ExpiryTime < @Now)") <- [ "@Now" = now ];
        def rows = command.executeNonQuery();
        Log.i("Deleted {0} expired session tokens...", rows);
    }

    public getUserIdFromSessionToken(tok: STOK, token: string): uint? {
        expireSessionTokens();
        def commmand = Database.createCommand(
            "SELECT (UserId) FROM Sessions WHERE "
                "(Token = @Token AND IsSecure = @IsSecure)") <- [
            "@Token" = token,
            "@IsSecure" = tok.IsSecure(),
        ];
        commmand.executeScalar() :> uint?;
    }
}


} // namespace forum
