using System;
using System.Security.Cryptography;

using httplib;


namespace forum.mod {

/** This interface describes a PBKDF2-based Authentication module based in part
 *  on Taylor Hornby's implementation in C#, available at:
 *  https://crackstation.net/hashing-security.htm#aspsourcecode */
public interface IAuth: IModuleInterface {

    /** Number of PBKDF2 iterations to run when generating passwords. */
    IterationCount: int { get }

    /** Length of password hashes and salts. */
    HashLength: int { get }

    /** Generate a new unique salt value. */
    createSalt(): array[byte];

    /** Generate a PBKDF2 hash of a user-supplied password. */
    hashPassword(
        pw: string, salt: array[byte], iter: int, length: int): array[byte];

    /** Given a user-supplied password, return a pipe-delimited record which
     *  specifies the password hash, and the parameters used to generate it
     *  (salt, iterations, hash length, algorithm(=PBKDF2) etc...) */
    createPasswordRecord(pw: string): string;

    /** Validate a user-supplied password against the record generated by
     *  createPasswordRecord(). */
    validatePassword(pw: string, record: string): bool;

    /** Compare password hashes in constant time. Attempts to avoid 'leaking'
     *  timing information. */
    compareHashes(a: array[byte], b: array[byte]): bool;
}


[HasLogging]
public class Auth: Module, IAuth {

    public override InterfaceType: Type {
        get { typeof(IAuth) }
    }

    Salt: RNGCryptoServiceProvider { get; private set; }

    public IterationCount: int { get; private set; }
    public HashLength: int { get; private set; }

    public this() {
        initialize();
    }

    public this(conf: ModuleData) {
        initialize(conf);
    }

    initialize(conf: ModuleData = null): void {
        Log.i("Starting Auth module... (conf: {0})", conf);
        Salt = RNGCryptoServiceProvider();
        IterationCount = 12500;
        HashLength = 40;

        when(conf != null) {
            mutable probe;
            when(conf.TryGetValue("IterationCount", out probe)) {
                IterationCount = Int32.Parse(probe);
            }
            when(conf.TryGetValue("HashLength", out probe)) {
                HashLength = Int32.Parse(probe);
            }
        }
    }

    public createSalt(): array[byte] {
        mutable result: array[byte] = array(HashLength);
        Salt.GetBytes(result);
        result;
    }

    public hashPassword(
        pw: string, salt: array[byte], iter: int, length: int): array[byte] {

        def pbkdf2 = Rfc2898DeriveBytes(pw, salt);
        pbkdf2.IterationCount = iter;
        pbkdf2.GetBytes(length);
    }

    public createPasswordRecord(pw: string): string {
        def salt = createSalt();
        def hash = hashPassword(pw, salt, IterationCount, HashLength);
        "PBKDF2|" + IterationCount + "|" + HashLength + "|" +
        Convert.ToBase64String(salt) + "|" + Convert.ToBase64String(hash);
    }

    public validatePassword(pw: string, record: string): bool {
        def split = record.Split(array['|']);
        def algo = split[0];
        def iter = Int32.Parse(split[1]);
        def len = Int32.Parse(split[2]);
        def salt = Convert.FromBase64String(split[3]);
        def hash = Convert.FromBase64String(split[4]);
        def test = hashPassword(pw, salt, iter, len);

        compareHashes(hash, test) && ("PBKDF2" == algo);
    }

    public compareHashes(a: array[byte], b: array[byte]): bool {
        mutable cmp: int = a.Length ^ b.Length;
        def min = Math.Min(a.Length, b.Length);
        for(mutable i = 0; i < min; i++) {
            cmp |= a[i] ^ b[i];
        }
        cmp == 0;
    }
}


} // namespace forum.mod
