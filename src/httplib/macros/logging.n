using Nemerle;
using Nemerle.Compiler;


namespace httplib {

/** [HasLogging] */
[MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
macro HasLogging(typeBuilder : TypeBuilder, params args: list[PExpr]) {

    mutable lazy_init = false;

    foreach(a in args) {
        match(a) {
            | <[ LazyInit ]> => lazy_init = true;
            | _ as x => Message.Error(
                $"'$x' is not a valid argument to HasLogging macro");
        }
    }

    if(lazy_init) {
        typeBuilder.Define( <[ decl: mutable log: ILog; ]> );

        typeBuilder.Define( <[ decl:
            public Log: ILog {
                get {
                    when(log == null) {
                        log = Logging.forThisType();
                    }
                    log;
                }
            } ]> );

    } else {
        typeBuilder.Define( <[ decl:
            log: ILog = Logging.forThisType(); ]> );

        typeBuilder.Define( <[ decl:
            public Log: ILog { get { log; } } ]> );
    }
}


} // namespace httplib
