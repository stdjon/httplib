using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text.RegularExpressions;

using CsQuery;

using OEmbed.Net;
using OEmbed.Net.Domain;


namespace httplib.mod {

//------------------------------------------------------------------------------
// "compiled" information about providers

[HasLogging]
public class ProviderData {

    public Name: string { get; private set; }
    public Type: EmbedType { get; private set; }
    public Endpoint: string { get; private set; }
    public Patterns: List[Regex] { get; private set; }

    public this(
        name: string, type: string,
        endpoint: string, patterns: List[string], self: OEmbed) {

        Name = name;
        Type = self.Types[type];
        Endpoint = endpoint;
        Patterns = List();

        foreach(p in patterns) {
            Patterns.Add(Regex(p));
        }
    }

    public virtual isMatch(url: string): bool {
        mutable result = false;
        exit: {
            foreach(p in Patterns) {
                when(p.IsMatch(url)) {
                    result = true;
                    exit();
                }
            }
        }
        result;
    }

    public load(url: string): Provider {
        def assembly = Assembly.LoadFrom(Type.Assembly);
        def type = assembly.GetType(Type.Typename);

        Log.d("ProviderData.load({0}): [{1}] {2}", url, type, assembly);

        Activator.CreateInstance(type, Endpoint, url) :> Provider;
    }
}


//------------------------------------------------------------------------------
// Base class for providers

[HasLogging]
public class Provider {

    public Endpoint: string { get; private set; }
    public Url: string { get; private set; }

    public this(endpoint: string, url: string) {
        Endpoint = endpoint;
        Url = url;
    }

    public virtual transform(): string {
        Url;
    }

    // Converts a bare URL to <a href="URL">URL</a>
    public virtual makeUrl(title: string = null): string {
        def t = title ? title : Url;
        $"<a href='$Url' rel='nofollow'>$t</a>";
    }
}


public type Providers = List[Provider];


//------------------------------------------------------------------------------
// Default URL Provider

public class DefaultUrlProvider: Provider {
    public this(endpoint: string, url: string) {
        base(endpoint, url);
    }

    public override transform(): string {
        makeUrl();
    }
}


//------------------------------------------------------------------------------
// OEmbed providers (photo, video)

public class OEmbedProvider: Provider {

    public this(endpoint: string, url: string) {
        base(endpoint, url);
    }

    public OEmbedUrl: string {
        get {
            $"$(Endpoint)?url=$(Uri.EscapeDataString(Url))&format=json"
        }
    }
}


public class OEmbedPhotoProvider: OEmbedProvider {

    public this(endpoint: string, url: string) {
        base(endpoint, url);
    }

    public override transform(): string {
        def o = Consumer.[Photo]();
        def d = o.GetObject(OEmbedUrl);
        $"<img src='$(d.Url)' height='$(d.Height)' width='$(d.Width)'></img>";
    }
}


public class OEmbedVideoProvider: OEmbedProvider {

    public this(endpoint: string, url: string) {
        base(endpoint, url);
    }

    public override transform(): string {
        def o = Consumer.[Video]();
        def d = o.GetObject(OEmbedUrl);
        d.Html;
    }
}


//------------------------------------------------------------------------------
// Makes a generic HTTP GET request and allows CsQueries on the response data.

public class HttpQueryProvider: Provider {

    public Query: CQ { get; private set; }

    public this(endpoint: string, url: string) {
        base(endpoint, url);

        def request = WebRequest.Create(url) :> HttpWebRequest;
        def response = request.GetResponse() :> HttpWebResponse;
        def stream = response.GetResponseStream();
        // The weird syntax on the next line is us telling NCC that we want to
        // use the single-argument version of CQ.Create(stream), which for some
        // reason, it is unable to deduce...
        Query = (CQ.Create: Stream -> CQ)(stream);
    }

    public virtual query(selector: string): string {
        Query.Select(selector).SelectionHtml(true);
    }
}


} // namespace httplib.mod
