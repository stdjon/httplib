using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

using YamlDotNet.Serialization; // for [YamlIgnore]


namespace httplib {

//------------------------------------------------------------------------------
// FileType

public type FileType = FILE;
public enum FILE {
    | JS
    | CSS
}


public type JoinType = JOIN;
public enum JOIN {
    | CAT
    | MIN
}


public module FileTypeExtensions {

    public extension(this ft: FileType): string {
        match(ft) {
            | JS => "js"
            | CSS => "css"
        }
    }
    public rename(this ft: FileType, path: string): string {
        Path.ChangeExtension(path, ft.extension());
    }
}


//------------------------------------------------------------------------------
// Page

[YamlRecord]
[HasLogging]
public class Page {

    type Dict[T] = Dictionary[string, T];
    public type PartialsType = Dict[string];
    public type ObjectsType = Dict[object];

    public Path: string { get; set; }
    public Lang: string { get; set; }
    public Metas: List[string] { get; set; }
    public Title: string { get; set; }
    public Stylesheets: List[string] { get; set; }
    public Scripts: List[string] { get; set; }
    public BodyAttributes: List[string] { get; set; }
    public Content: string { get; set; }
    public Partials: PartialsType { get; set; }
    public Objects: ObjectsType { get; set; }
    public Template: string { get; set; }

    [YamlIgnore]
    public Server: Server { get; set; }

    public virtual render(
        data: ObjectsType = null, parts: PartialsType = null): string {

        def lang =
            !String.IsNullOrEmpty(Lang) ? $" lang='$Lang'" : "";

        def t = renderTitle(data);
        def title =
            !String.IsNullOrEmpty(t) ? $"\n<title>$t</title>" : "";

        mutable meta = "";
        when(Metas != null) {
            foreach(m in Metas) {
                when(!String.IsNullOrEmpty(m)) {
                    meta += $"\n<meta $(renderString(m, data))>"
                }
            }
        }

        def conf = Server.Configuration.Consolidation.Types;
        mutable probe;
        when(conf.TryGetValue("Scripts", out probe)) {
            when("cat" == probe) {
                consolidateScripts(JOIN.CAT);
            }
        }

        when(conf.TryGetValue("Stylesheets", out probe)) {
            when("cat" == probe) {
                consolidateStylesheets(JOIN.CAT);
            }
        }

        def stylesheet = renderFileElementList(
            Stylesheets, "link/href/rel='stylesheet'", data);
        def script = renderFileElementList(Scripts, "script/src", data);

        mutable body_attrs = "";
        when(BodyAttributes != null) {
            foreach(b in BodyAttributes) {
                when(!String.IsNullOrEmpty(b)) {
                    body_attrs += $" $b";
                }
            }
        }

        // insert "_Scripts" into partial data for content render, so client has
        // control over where scripts are placed within a page.
        mutable pd = PartialsType();
        pd["_Scripts"] = script;
        pd = mergeDicts(parts, pd);

        def content = renderContent(data, pd);

        $"<!DOCTYPE html>\n<html$lang>\n"
        $"<head>$meta$title$stylesheet\n</head>\n"
        $"<body$body_attrs>\n$content</body>\n</html>";
    }

    public virtual renderContent(
        data: ObjectsType = null, parts: PartialsType = null): string {

        renderString(Content, data, parts);
    }

    public virtual renderTitle(data: ObjectsType = null): string {

        renderString(Title, data, null);
    }

    protected virtual renderString(template: string,
        _data: ObjectsType, _parts: PartialsType = null): string {

        template;
    }

    protected virtual renderFileElementList(
        paths: List[string], template: string, data: ObjectsType = null): string {
        mutable result = "";
        def split = template.Split(array['/'], 3);
        def (tag, loc, attr) = (split[0], split[1], split.Length > 2 ? split[2] : "");
        when(paths != null) {
            foreach(p in paths) {
                // It's occasionally useful to have a file element which has an
                // associated id attribute. If a file path contains a '#'
                // character, we will use everything after it as the id name:
                // - /path/to/file.ext#file-id
                when(!String.IsNullOrEmpty(p)) {
                    def attrs =
                        if(p.Contains("#")) {
                            def a = p.Split(array['#'], 2);
                            $"$loc='$(renderString(a[0], data))' id='$(a[1])'";
                        } else if(p.Contains("*")) {
                            def a = p.Split(array['*'], 2);
                            $"$loc='$(renderString(a[0], data))' id='$(a[1])'";
                        } else {
                            $"$loc='$(renderString(p, data))'";
                        };
                    result += $"\n<$tag $attr $attrs></$tag>"
                }
            }
        }
        result;
    }

    public consolidateScripts(type: JoinType = JOIN.CAT): void {
        def (ok, files) = consolidateFiles(FILE.JS, type, Scripts);
        when(ok) {
            Scripts = files;
        }
    }

    public consolidateStylesheets(type: JoinType = JOIN.CAT): void {
        def (ok, files) = consolidateFiles(FILE.CSS, type, Stylesheets);
        when(ok) {
            Stylesheets = files;
        }
    }

    protected consolidateFiles(
        ftype: FileType, _jtype: JoinType, files: List[string]): bool * List[string] {

        mutable x = List();
        def path = Path.Replace('/', '_').Replace('\\', '_');
        mutable result = false;
        def output = ftype.rename($"/_$path");
        def pth = Server.canonicalPath(Server.Configuration.Consolidation.CachePath);
        def outpath = $"$pth$output";

        using(ostream = FileStream(outpath, FileMode.Create, FileAccess.Write)) {
            when(ostream != null) {
                foreach(f in files) {
                    if(f.Contains("*")) {
                        def i = f.Split(array['*']);
                        x.Add(i[0]);
                    } else {
                        def g = ('/' == f[0]) ? f.Substring(1) : f;
                        using(istream = Server.openLocalFile(g)) {
                            if(istream != null) {
                                istream.CopyTo(ostream);
                            } else {
                                x.Add(f);
                            }
                        }
                    }
                }
                result = true;
            }
        }
        when(result) {
            x.Add(output);
        }

        (result, x);
    }

    public merge(other: Page): void {
        when(Lang == null) {
            Lang = other.Lang;
        }
        when(Title == null) {
            Title = other.Title;
        }
        when(Content == null) {
            Content = other.Content;
        }
        Metas = mergeLists(other.Metas, Metas);
        Stylesheets = mergeLists(other.Stylesheets, Stylesheets);
        Scripts = mergeLists(other.Scripts, Scripts);
        BodyAttributes = mergeLists(other.BodyAttributes, BodyAttributes);
        Partials = mergeDicts(other.Partials, Partials);
        Objects = mergeDicts(other.Objects, Objects);
    }

    protected static mergeLists(
        a: List[string], b: List[string]): List[string] {
        mutable result = List();

        when(a != null) {
            foreach(m in a) {
                result.Add(m);
            }
        }
        when(b != null) {
            foreach(m in b) {
                result.Add(m);
            }
        }
        result;
    }

    protected static mergeDicts[T](a: Dict[T], b: Dict[T]): Dict[T] {
        mutable result = Dict();

        when(a != null) {
            foreach(m in a) {
                result.Add(m.Key, m.Value);
            }
        }
        when(b != null) {
            foreach(m in b) {
                result[m.Key] = m.Value;
            }
        }
        result;
    }
}


} // namespace httplib
