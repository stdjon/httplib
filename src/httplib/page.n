using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;


namespace httplib {

//------------------------------------------------------------------------------
// Page

[YamlRecord]
public class Page {

    type Dict[T] = Dictionary[string, T];
    public type PartialsType = Dict[string];
    public type ObjectsType = Dict[object];

    public Path: string { get; set; }
    public Lang: string { get; set; }
    public Metas: List[string] { get; set; }
    public Title: string { get; set; }
    public Stylesheets: List[string] { get; set; }
    public Scripts: List[string] { get; set; }
    public BodyAttributes: List[string] { get; set; }
    public Content: string { get; set; }
    public Partials: PartialsType { get; set; }
    public Objects: ObjectsType { get; set; }
    public Template: string { get; set; }

    public virtual render(
        data: ObjectsType = null, parts: PartialsType = null): string {

        def lang =
            !String.IsNullOrEmpty(Lang) ? $" lang='$Lang'" : "";

        def t = renderTitle(data);
        def title =
            !String.IsNullOrEmpty(t) ? $"\n<title>$t</title>" : "";

        mutable meta = "";
        when(Metas != null) {
            foreach(m in Metas) {
                when(!String.IsNullOrEmpty(m)) {
                    meta += $"\n<meta $(renderString(m, data))>"
                }
            }
        }

        def stylesheet = renderFileElementList(
            Stylesheets, "link/href/rel='stylesheet'", data);
        def script = renderFileElementList(Scripts, "script/src", data);

        mutable body_attrs = "";
        when(BodyAttributes != null) {
            foreach(b in BodyAttributes) {
                when(!String.IsNullOrEmpty(b)) {
                    body_attrs += $" $b";
                }
            }
        }

        // insert "_Scripts" into partial data for content render, so client has
        // control over where scripts are placed within a page.
        mutable pd = PartialsType();
        pd["_Scripts"] = script;
        pd = mergeDicts(parts, pd);

        def content = renderContent(data, pd);

        $"<!DOCTYPE html>\n<html$lang>\n"
        $"<head>$meta$title$stylesheet\n</head>\n"
        $"<body$body_attrs>\n$content</body>\n</html>";
    }

    public virtual renderContent(
        data: ObjectsType = null, parts: PartialsType = null): string {

        renderString(Content, data, parts);
    }

    public virtual renderTitle(data: ObjectsType = null): string {

        renderString(Title, data, null);
    }

    protected virtual renderString(template: string,
        _data: ObjectsType, _parts: PartialsType = null): string {

        template;
    }

    protected virtual renderFileElementList(
        paths: List[string], template: string, data: ObjectsType = null): string {
        mutable result = "";
        def split = template.Split(array['/'], 3);
        def (tag, loc, attr) = (split[0], split[1], split.Length > 2 ? split[2] : "");
        when(paths != null) {
            foreach(p in paths) {
                // It's occasionally useful to have a file element which has an
                // associated id attribute. If a file path contains a '#'
                // character, we will use everything after it as the id name:
                // - /path/to/file.ext#file-id
                when(!String.IsNullOrEmpty(p)) {
                    def attrs =
                        if(p.Contains("#")) {
                            def a = p.Split(array['#'], 2);
                            $"$loc='$(renderString(a[0], data))' id='$(a[1])'";
                        } else {
                            $"$loc='$(renderString(p, data))'";
                        };
                    result += $"\n<$tag $attr $attrs></$tag>"
                }
            }
        }
        result;
    }

    public merge(other: Page): void {
        when(Lang == null) {
            Lang = other.Lang;
        }
        when(Title == null) {
            Title = other.Title;
        }
        when(Content == null) {
            Content = other.Content;
        }
        Metas = mergeLists(other.Metas, Metas);
        Stylesheets = mergeLists(other.Stylesheets, Stylesheets);
        Scripts = mergeLists(other.Scripts, Scripts);
        BodyAttributes = mergeLists(other.BodyAttributes, BodyAttributes);
        Partials = mergeDicts(other.Partials, Partials);
        Objects = mergeDicts(other.Objects, Objects);
    }

    protected static mergeLists(
        a: List[string], b: List[string]): List[string] {
        mutable result = List();

        when(a != null) {
            foreach(m in a) {
                result.Add(m);
            }
        }
        when(b != null) {
            foreach(m in b) {
                result.Add(m);
            }
        }
        result;
    }

    protected static mergeDicts[T](a: Dict[T], b: Dict[T]): Dict[T] {
        mutable result = Dict();

        when(a != null) {
            foreach(m in a) {
                result.Add(m.Key, m.Value);
            }
        }
        when(b != null) {
            foreach(m in b) {
                result[m.Key] = m.Value;
            }
        }
        result;
    }
}


} // namespace httplib
