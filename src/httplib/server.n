using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Text.Encoding;
using System.Text.RegularExpressions;

using Nemerle.IO;
using Nemerle.Utility;


namespace httplib {


//------------------------------------------------------------------------------
// HTTP (method)

// Defined in order used in http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
public enum HTTP {
    | INVALID_

    | OPTIONS
    | GET
    | HEAD
    | POST
    | PUT
    | DELETE
    | TRACE
    | CONNECT

    | COUNT_
}



//------------------------------------------------------------------------------
// IAssociation
// NB: we may want to vary on the association value type as well (for cookies).

public interface IAssociation[T] {
    public type SystemType = T;

    Item[key: string]: string { get; }
    Keys: array[string] { get; }
    forEach(lambda: string * string -> void): void;
    toSystemType(): T;
}


//------------------------------------------------------------------------------
// Array

public class Array {

    type SystemType = array[string];

    arr: SystemType;

    public this(data: SystemType) {
        arr = data;
    }

    public Item[index: int]: string {
        get { arr[index]; }
    }

    public Length: int {
        get { arr.Length; }
    }

    public forEach(lambda: string -> void): void {
        foreach(v in arr) {
            lambda(v);
        }
    }

    public toSystemType(): SystemType {
        arr;
    }
}


//------------------------------------------------------------------------------
// HashTable

public class HashTable: IAssociation[NameValueCollection] {

    type SystemType = NameValueCollection;

    nvc: SystemType;

    public this() {
        nvc = SystemType();
    }

    public this(data: SystemType) {
        nvc = data;
    }

    public Item[key: string]: string {
        get { nvc[key]; }
        set { nvc[key] = value; }
    }

    public Keys: array[string] {
        get { nvc.AllKeys; }
    }

    public forEach(lambda: string * string -> void): void {
        foreach(k in Keys) {
            lambda(k, Item[k]);
        }
    }

    public toSystemType(): SystemType {
        nvc;
    }
}


//------------------------------------------------------------------------------
// CookieTable

public class CookieTable: IAssociation[CookieCollection] {

    type SystemType = CookieCollection;

    cc: SystemType;
    // As long as Item[key].set is unimplemented (i.e. cc can't change), we can
    // cache the cookie keys...
    mutable keys: array[string];

    public this() {
        cc = SystemType();
        keys = null;
    }

    public this(data: SystemType) {
        cc = data;
    }

    public Item[key: string]: string {
        get { cc[key].Value.ToString(); }
//        set { cc[key] = value; }
    }

    public Keys: array[string] {
        get { cachedKeys(); }
    }

    public forEach(lambda: string * string -> void): void {
        foreach(k in Keys) {
            lambda(k, Item[k]);
        }
    }

    public toSystemType(): SystemType {
        cc;
    }

    cachedKeys(): array[string] {
        when(keys == null) {
            def k = cc.Count;
            mutable result: array[string];

            Array.Resize(ref result, k);
            for(mutable i = 0; i < k; i++) {
                result[i] = cc[i].Name;
            }
            keys = result;
        }
        keys;
    }
}


//------------------------------------------------------------------------------
// Request

public class Request {

    [Accessor] http_method: string;
    [Accessor] url: Uri;
    [Accessor] raw_url: string;
    [Accessor] query_string: HashTable;
    [Accessor] headers: HashTable;
    [Accessor] cookies: CookieTable;
    [Accessor] path: Array;
    [Accessor] accept: Array;
    [Accessor] raw_path: string;
    [Accessor] user_agent: string;
    [Accessor] is_authenticated: bool;
    [Accessor] is_secure: bool;
    [Accessor] is_web_socket: bool;
    [Accessor] http_version: int;
    // TODO: is it possible to refactor these setters/mutables away?
    [Accessor(flags = WantSetter)] mutable vars: HashTable;
    [Accessor(flags = WantSetter)] mutable file_stream: FileStream;
    [Accessor(flags = WantSetter)] mutable searched_for_file_stream: bool;
    [Accessor(flags = WantSetter)] mutable extension: string;

    // Convenience wrapper for headers
    public Item[key: string]: string {
        get { Headers[key] }
    }

    public this(req: HttpListenerRequest) {

        http_method = req.HttpMethod;
        url = req.Url;
        raw_url = req.RawUrl;
        query_string = HashTable(req.QueryString);
        headers = HashTable(req.Headers);
        cookies = CookieTable(req.Cookies);
        path = makePathArray(RawUrl);
        accept = Array(req.AcceptTypes);
        raw_path = makeRawPath(Path);
        user_agent = req.UserAgent;
        is_authenticated = req.IsAuthenticated;
        is_secure = req.IsSecureConnection;
        is_web_socket = req.IsWebSocketRequest;
        http_version = makeHttpVersion(req.ProtocolVersion);
        vars = HashTable();
        file_stream = null;
        searched_for_file_stream = false;
        extension = makeExtension(Path);
    }

    /** convert a RawUrl -> path component Array
     *  "/a/b//c" -> [ "a", "b", "c" ] */
    makePathArray(raw_url: string): Array {

        def path_only = raw_url.Split(array['?'], StringSplitOptions.None);
        def path_section =
            if(path_only.Length > 0) {
                path_only[0]
            } else {
                raw_url
            };
        def path_split = path_section.Split(
            array['/'], StringSplitOptions.RemoveEmptyEntries );

        Array(path_split);
    }

    makeExtension(path: Array, full: bool = false): string {

        def last_path =
            if(path.Length > 0) {
                path[path.Length - 1];
            } else {
                ""
            }
        def last_split = last_path.Split(
            array['.'], StringSplitOptions.None );

        if(last_split.Length > 1) {
            if(full) {
                def len = last_split.Length - 1;
                mutable tmp: array[string] = array(len);
                Array.Copy(last_split, 1, tmp, 0, len);
                String.Join(".", tmp)
            } else {
                last_split[last_split.Length - 1];
            }
        } else {
            ""
        }
    }

    //TODO: "/" + String.Join("/", ...)
    makeRawPath(path: Array): string {
        String.Join("/", path.toSystemType());
    }

    makeHttpVersion(version: Version): int {
        (version.Major) + 10 + (version.Minor);
    }

    internal complete(): void {
        def fs = FileStream;
        when(fs != null) {
            fs.Close();
        }
    }
}


//------------------------------------------------------------------------------
// Response

public class Response {

    public ContentLength: long {
        get { response.ContentLength64 }
        set { response.ContentLength64 = value; }
    }

    public ContentType: string {
        get { response.ContentType }
        set { response.ContentType = value; }
    }


    public StatusCode: int {
        get { response.StatusCode }
        set { response.StatusCode = value; }
    }

    public StatusDescription: string {
        get { response.StatusDescription }
        set { response.StatusDescription = value; }
    }

    // Convenience wrapper around (StatusCode, StatusDescription)
    public Status: int * string {
        get { (StatusCode, StatusDescription) }
        set { (StatusCode, StatusDescription) = value; }
    }

    // Convenience wrapper for headers
    public Item[key: string]: string {
        get { response.Headers[key] }
        set { response.Headers[key] = value }
    }

    mutable response: HttpListenerResponse;
    mutable output: array[byte];

    public this(res: HttpListenerResponse, output_length = 1024) {

        response = res;
        output = array(output_length);
    }

    // interim API pending full cookie support...
    public setCookie(name: string, value: string): void {
        response.AppendCookie(Cookie(name, value, "/"));
    }

    public append(params data: array[string]): void {
        appendArray(data);
    }

    public appendArray(data: array[string]): void {

        foreach(d in data) {
            def buffer = UTF8.GetBytes(d);
            writeToOutput(buffer);
        }
    }

    public appendBytes(data: array[byte]): void {
        writeToOutput(data);
    }

    writeToOutput(data: array[byte]): void {
        def new_length = ContentLength + data.Length;

        when(output.Length < new_length) {
            def _32 = output.Length * 3 / 2;
            def nl = if(_32 > new_length) { _32 } else { new_length :> int }
            Array.Resize(ref output, nl);
        }

        data.CopyTo(output, ContentLength);
        ContentLength = new_length;
    }

    internal complete(): void {
        def os = response.OutputStream;
        os.Write(output, 0, ContentLength :> int);
        os.Close();
    }
}


//------------------------------------------------------------------------------
// ServerConfiguration

[Record]
public class ServerConfiguration {

    /** Listener prefixes */
    [Accessor(flags = WantSetter)] mutable prefixes: array[string];
    /** Filesystem roots for file serving */
    [Accessor(flags = WantSetter)] mutable roots: array[string];
    /** Extensions to try (in order) when no extension given in request URI */
    [Accessor(flags = WantSetter)] mutable implicit_extensions: array[string];
    /** Minimum length reserved for response body */
    [Accessor(flags = WantSetter)] mutable output_length: int;
}


//------------------------------------------------------------------------------
// Route

public class Route {

    [Accessor] pattern: string;
    regex: Regex;
    mutable captures: array[string] = array(0);

    public this(path: string) {

        mutable rx = path;

        // {{name}}  -->  ([A-Za-z0-9.-]+)
        process(ref rx, @"{{(\w+)}}", _ => { @"([A-Za-z0-9_.-]+)" });

        // {{name:pattern}}  -->  (pattern)
        process(ref rx, @"{{(\w+):(.+)}}", p => { "(" + p + ")" });

        //anchor start/end of regex
        rx = "^" + rx + "$";

        regex = Regex(rx);
        pattern = rx;
    }

    public isMatch(path: string): bool {
        regex.IsMatch(path)
    }

    public doMatch(path: string): bool * HashTable {
        mutable vars = HashTable();
        def result = regex.IsMatch(path);

        when(result) {
            def _ = regex.Replace(path, m => {

                for(mutable i = 1; i < m.Groups.Count; i++) {
                    def k = captures[i - 1];
                    def v = m.Groups[i].ToString();
                    vars[k] = v;
                }
                ""
            }, 100, 0);
        }
        (result, vars);
    }

    process(input: ref string, pattern: string, replace: string -> string): void {
        input = Regex.Replace(input, pattern, m => {

            def v: string = m.Groups[1].ToString();
            def patt: string = m.Groups[2].ToString();
            def e = captures.Length;

            Array.Resize(ref captures, e + 1);
            captures[e] = v;

            replace(patt);
        });
    }
}


//------------------------------------------------------------------------------
// Server

public abstract class Server: IDisposable {

    public type Callback = Request * Response -> void;
    type RouteMap = Dictionary[string, Route * Callback];

    type Method = HTTP;
    public static MethodCount = HTTP.COUNT_ :> int;

    [System.Flags]
    public enum State {
        | Neutral = 0x00
        | Running = 0x01
        | Closed = 0x02
    }

    [Accessor(Flags, flags = Protected)]
    [FlagAccessor(Running, flags = Protected | WantSetter)]
    [FlagAccessor(Closed, flags = Protected | WantSetter)]
    mutable state: State = State.Neutral;

    [Accessor(flags = Protected)]
    listener: HttpListener = HttpListener();

    [Accessor(flags = Protected)]
    configuration: ServerConfiguration;

    public Routes[i: Method]: RouteMap {
        get { routes[i :> int] }
    }
    routes: array[RouteMap] = array(MethodCount);

    public this(config: ServerConfiguration) {

        configuration = config;

        foreach(p in Configuration.Prefixes) {
            print("Adding \"$p\"...\n");
            Listener.Prefixes.Add(p);
        }
        for(mutable i = 0; i < MethodCount; i++) {
            routes[i] = Dictionary();
        }

        // install default handlers for several methods...
        route(HTTP.INVALID_, ".*", internalServerErrorResponse);
        route(HTTP.OPTIONS, ".*", methodNotAllowedResponse);
        route(HTTP.TRACE, ".*", methodNotAllowedResponse);
        route(HTTP.CONNECT, ".*", methodNotAllowedResponse);

        Listener.AuthenticationSchemeSelectorDelegate = req => {
            def request = Request(req);
            handleAuthentication(request);
        };


        Listener.Start();
    }

    public Dispose(): void {
        shutdown();
    }

    protected override Finalize(): void {
        shutdown();
    }

    shutdown(): void {

        when(!Closed) {
            Listener.Close();
            Running = false;
            Closed = true;
        }
    }

    // route("/a/b/c", r => { })
    public route(method: Method, path: string, fn: Callback): void {
        def route = Route(path);
        def pattern = route.Pattern;
        print("route: $(methodName(method)) '$(path)' added $(fn)\n");
        Routes[method].Add(pattern, (route, fn));
    }

    public update(): void {
        Running = true;
        def _ = Listener.BeginGetContext(listenerCallback, this);
    }

    findCallback(method_name: string, path: string, vars_out: ref HashTable): Callback {
        mutable result;
        exit: {
            def method = methodType(method_name);
            foreach(r in Routes[method]) {
                def (route, fn) = r.Value;
                def (ok, vars) = route.doMatch(path);

                when(ok) {
                    print("'$(path)' matches '$(route.Pattern)'...\n");
                    result = fn;
                    vars_out = vars;
                    exit();
                }
            }
        }
        result;
    }

    /** Overridden by child classes */
    protected virtual internalServerError(_: Exception): void {
        //...
    }

    /** Overridden by child classes */
    protected virtual handleAuthentication(
        _request: Request): AuthenticationSchemes {

        AuthenticationSchemes.Anonymous;
    }

    /** Overridden by child classes */
    protected abstract callback(request: Request, response: Response): void;

    handleCallback(context: HttpListenerContext): void {
        mutable request, response;
        try {
            request = Request(context.Request);
            response = Response(context.Response, Configuration.OutputLength);

            print("Requesting: \"/$(request.RawPath)\"...\n");

            // check for existing file under roots...
            def (fs, ext) = findLocalFileForRequest(request);
            request.FileStream = fs;

            when(!String.IsNullOrEmpty(ext)) {
                request.SearchedForFileStream = true;
                request.Extension = ext;
            }

            // find callback (and populate vars from route vars if any)
            mutable vars = HashTable();
            def cb = findCallback(request.HttpMethod, "/" + request.RawPath, ref vars);

            // populate vars from body of POST...
            when(HTTP.POST == methodType(request.HttpMethod)) {
                processPostInputStream(context.Request, ref vars);
            }

            if(cb != null) {
                request.Vars = vars;
                cb(request, response);
            } else {
                callback(request, response);
            }
        } catch {
            | ex => {
                internalServerError(ex);
                internalServerErrorResponse(request, response);
            }
        } finally {
            print($"Response Status: $(response.StatusCode) "
                $"$(response.StatusDescription)\n");
            // TODO: using() may be more appropriate here (if request/response
            //   gain Dispose() methods...)
            request.complete();
            response.complete();
        }
    }

    static listenerCallback(result: IAsyncResult): void {
        def server = result.AsyncState :> Server;
        def context = server.Listener.EndGetContext(result);

        server.handleCallback(context);
    }

    openLocalFile(path: string): FileStream {
        mutable result = null;
        exit: {
            foreach(root in Configuration.Roots) {
                def p = Path.Combine(root, path);
                def exists = File.Exists(p);
                def x = if(exists) { "yes" } else { "no" }

                print($"File exists: \"$p\"? $x\n");
                when(exists) {
                    result = FileStream(p, FileMode.Open);
                    exit();
                }
            }
        }
        result;
    }

    findLocalFileForRequest(request: Request): FileStream * string {
        mutable result = null, ext = null;
        if(!String.IsNullOrEmpty(request.Extension)) {
            result = openLocalFile(request.RawPath);

        } else {
            exit: {
                foreach(x in Configuration.ImplicitExtensions) {
                    result = openLocalFile(request.RawPath + "." + x);
                    when(result != null) {
                        ext = x;
                        exit();
                    }
                }
            }
        }
        (result, ext);
    }

    processPostInputStream(
        request: HttpListenerRequest, vars_out: ref HashTable): void {

        when(request.InputStream != null) {
            using(mutable reader = StreamReader(
                request.InputStream, request.ContentEncoding)) {

                def str = reader.ReadToEnd();
                def each_var = str.Split(array['&', ';'], StringSplitOptions.None);

                when(each_var.Length > 0) {
                    foreach(v in each_var) {
                        def s = v.Split(array['='], StringSplitOptions.None);

                        when(s.Length > 1) {
                            vars_out[s[0].ToString()] = s[1].ToString();
                        }
                    }
                }
            }
        }
    }

    static methodType(name: string): Method {
        match(name.ToUpper()) {
            | "OPTIONS" => HTTP.OPTIONS
            | "GET" => HTTP.GET
            | "HEAD" => HTTP.HEAD
            | "POST" => HTTP.POST
            | "PUT" => HTTP.PUT
            | "DELETE" => HTTP.DELETE
            | "TRACE" => HTTP.TRACE
            | "CONNECT" => HTTP.CONNECT
            | _ => HTTP.INVALID_
        }
    }

    static methodName(mth: Method): string {
        match(mth) {
            | HTTP.OPTIONS => "OPTIONS"
            | HTTP.GET => "GET"
            | HTTP.HEAD => "HEAD"
            | HTTP.POST => "POST"
            | HTTP.PUT => "PUT"
            | HTTP.DELETE => "DELETE"
            | HTTP.TRACE => "TRACE"
            | HTTP.CONNECT => "CONNECT"
            | _ => "?"
        }
    }

    // stock request handlers (can be overridden by clients).

    protected virtual internalServerErrorResponse(
        _req: Request, res: Response): void {

        res.append(
            "<html><body><h1>500 Internal Server Error</h1></body><html>");
        res.Status = (500, "Internal Server Error");
    }

    protected virtual methodNotAllowedResponse(
        _req: Request, res: Response): void {

        res.append(
            "<html><body><h1>405 Method Not Allowed</h1></body><html>");
        res.Status = (405, "Method Not Allowed");
    }
}


} // namespace httplib
