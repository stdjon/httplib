using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Text.Encoding;
using System.Text.RegularExpressions;

using Nemerle.IO;
using Nemerle.Utility;

using YamlDeserializer = YamlDotNet.Serialization.Deserializer;


namespace httplib {

//------------------------------------------------------------------------------
// Server

public abstract class Server: IDisposable {

    public type Callback = Context * Request * Response -> void;
    type MakeHandler = HandlerData -> Handler;
    type RouteMap = Dictionary[string, Route * MakeHandler];
    type ContextMap = Dictionary[string, Route * PageData];

    type Method = HTTP;
    public static MethodCount = HTTP.COUNT_ :> int;

    [Accessor]
    static deserializer: YamlDeserializer = YamlDeserializer();

    [System.Flags]
    public enum State {
        | Neutral = 0x00
        | Running = 0x01
        | Closed = 0x02
    }

    [Accessor(Flags, flags = Protected)]
    [FlagAccessor(Running, flags = WantSetter)]
    [FlagAccessor(Closed, flags = Protected | WantSetter)]
    mutable state: State = State.Neutral;

    [Accessor(flags = Protected)]
    listener: HttpListener = HttpListener();

    [Accessor(flags = Protected)]
    configuration: ServerConfiguration;

    [Accessor] database: Database;

    public Routes[i: Method]: RouteMap {
        get { routes[i :> int] }
    }
    routes: array[RouteMap] = array(MethodCount);

    public Contexts[i: Method]: ContextMap {
        get { contexts[i :> int] }
    }
    contexts: array[ContextMap] = array(MethodCount);

    [Accessor(flags = Internal)]
    renderers: Dictionary[string, Renderer] = Dictionary();

    static protected loadConfiguration[T](path: string): T {
        using(reader = StreamReader(path)) {
            Deserializer.Deserialize.[T](reader);
        }
    }

    public this(path: string) {
        def config = loadConfiguration.[ServerConfiguration](path);
        this(config);
    }

    public this(config: ServerConfiguration) {

        configuration = config;
        def db = config.Database;

        when(db != null &&
            db.Assembly != null &&
            db.Typename != null) {
            database = Database.load(db.Assembly, db.Typename, db.Connection);
        }

        foreach(p in Configuration.Prefixes) {
            print("Adding \"$p\"...\n");
            Listener.Prefixes.Add(p);
        }

        foreach(x in Configuration.Renderers) {
            def r = Renderer.load(x.Value.Assembly, x.Value.Typename);
            when(r != null) {
                print("Registering $r for $(x.Key) files...\n");
                Renderers[x.Key] = r;
            }
        }

        for(mutable i = 0; i < MethodCount; i++) {
            routes[i] = Dictionary();
            contexts[i] = Dictionary();
        }

        // install default handlers for several methods...
        route(HTTP.INVALID_, ".*", internalServerErrorResponse);
        route([
            (HTTP.OPTIONS, ".*"),
            (HTTP.TRACE, ".*"),
            (HTTP.CONNECT, ".*") ], methodNotAllowedResponse);

        Listener.AuthenticationSchemeSelectorDelegate = req => {
            def request = Request(req);
            handleAuthentication(request);
        };
    }

    public start(): void {
        Running = true;
        Listener.Start();
    }

    public Dispose(): void {
        shutdown();
    }

    protected override Finalize(): void {
        shutdown();
    }

    shutdown(): void {

        when(!Closed) {
            Listener.Close();
            Running = false;
            Closed = true;
        }
    }

    public route(method: Method, path: string, handler: MakeHandler): void {

        def route = Route(path);
        def pattern = route.Pattern;
        print("route: $(methodName(method)) '$(path)' added $(handler)\n");
        Routes[method].Add(pattern, (route, handler));
    }

    public route(routes: list[(Method * string)], handler: MakeHandler): void {
        foreach((method, path) in routes) {
            route(method, path, handler);
        }
    }

    public route(method: Method, path: string, fn: Callback): void {
        route(method, path, CallbackHandler.Wrapper(fn).unwrap);
    }

    public route(routes: list[(Method * string)], fn: Callback): void {
        foreach((method, path) in routes) {
            route(method, path, fn);
        }
    }

    public context(
        method: Method, path: string, data: PageData): void {

        def route = Route(path);
        def pattern = route.Pattern;
        print("context: $(methodName(method)) '$(path)' added $(data)\n");
        Contexts[method].Add(pattern, (route, data));
    }

    public context(contexts: list[(Method * string)], data: PageData): void {
        foreach((method, path) in contexts) {
            context(method, path, data);
        }
    }

    public update(): void {
        def _ = Listener.BeginGetContext(listenerCallback, this);
    }

    findHandler(method_name: string,
        path: string, vars_out: ref HashTable): MakeHandler {

        mutable result;
        exit: {
            def method = methodType(method_name);
            foreach(r in Routes[method]) {
                def (route, handler) = r.Value;
                def (ok, vars) = route.doMatch(path);

                when(ok) {
                    result = handler;
                    vars_out = vars;
                    exit();
                }
            }
        }
        result;
    }

    findContext(method_name: string, path: string): PageData {
        mutable result;
        exit: {
            def method = methodType(method_name);
            foreach(r in Contexts[method]) {
                def (route, data) = r.Value;
                def (ok, _) = route.doMatch(path);

                when(ok) {
                    result = data;
                    exit();
                }
            }
        }
        result;
    }

    public virtual renderPage(path: string, data: PageData = null): string {
        def ext = Path.GetExtension(path).Substring(1);

        using(stream = openLocalFile(path)) {
            def renderer = Renderers[ext];
            def page = renderer.loadPage(stream);

            page.render(data);
        }
    }

    /** Overridden by child classes */
    protected virtual internalServerError(_: Exception): void {
        //...
    }

    /** Overridden by child classes */
    protected virtual handleAuthentication(
        _request: Request): AuthenticationSchemes {

        AuthenticationSchemes.Anonymous;
    }

    protected virtual callback(
        context: Context, request: Request, response: Response): void {
        // If the context.SearchedForFileStream is true, it means that the
        // context.FileStream was found by searching via the Extensions
        // (which means that there should be a suitable Renderer available...)
        def fs = context.FileStream != null;
        def searched = context.SearchedForFileStream;
        def lambda =
            match((fs, searched)) {
                | (true, true) => renderPageResponse
                | (true, false) => serveFileResponse
                |  _ => notFoundRespose
            };
        lambda(context, request, response);
    }

    handleCallback(http_ctx: HttpListenerContext): void {
        mutable context, request, response;
        try {
            context = Context();
            request = Request(http_ctx.Request);
            response = Response(http_ctx.Response, Configuration.OutputLength);

            print("Requesting: \"/$(request.RawPath)\"...\n");

            // check for existing file under roots...
            def (fs, ext) = findLocalFileForRequest(request);
            context.FileStream = fs;

            when(!String.IsNullOrEmpty(ext)) {
                context.SearchedForFileStream = true;
                request.Extension = ext;
            }

            // find callback (and populate vars from route vars if any)
            mutable vars = HashTable();

            def handler = findHandler(
                request.HttpMethod, "/" + request.RawPath, ref vars);

            context.PageData = findContext(
                request.HttpMethod, "/" + request.RawPath);
            context.Vars = vars;

            // populate vars from body of POST...
            when(HTTP.POST == methodType(request.HttpMethod)) {
                processPostInputStream(http_ctx.Request, ref vars);
            }

            if(handler != null) {
                def hd = HandlerData(context, request, response, this);
                handler(hd).callback();
            } else {
                callback(context, request, response);
            }
        } catch {
            | ex => {
                internalServerError(ex);
                internalServerErrorResponse(context, request, response);
            }
        } finally {
            print($"Response Status: $(response.StatusCode) "
                $"$(response.StatusDescription)\n");
            try {
                context.complete();
                response.complete();
            } catch {
                | ex => {
                    internalServerError(ex);
                }
            }
        }
    }

    static listenerCallback(result: IAsyncResult): void {
        def server = result.AsyncState :> Server;
        def http_ctx = server.Listener.EndGetContext(result);

        server.handleCallback(http_ctx);
    }

    public openLocalFile(path: string): FileStream {
        mutable result = null;
        exit: {
            foreach(root in Configuration.Roots) {
                def p = Path.Combine(root, path);
                def exists = File.Exists(p);
                def x = if(exists) { "yes" } else { "no" }

                print($"File exists: \"$p\"? $x\n");
                when(exists) {
                    result = FileStream(p, FileMode.Open);
                    exit();
                }
            }
        }
        result;
    }

    findLocalFileForRequest(request: Request): FileStream * string {
        mutable result = null, ext = null;
        if(!String.IsNullOrEmpty(request.Extension)) {
            result = openLocalFile(request.RawPath);

        } else {
            exit: {
                foreach(x in Configuration.Renderers) {
                    result = openLocalFile(request.RawPath + "." + x.Key);
                    when(result != null) {
                        ext = x.Key;
                        exit();
                    }
                }
            }
        }
        (result, ext);
    }

    processPostInputStream(
        request: HttpListenerRequest, vars_out: ref HashTable): void {

        when(request.InputStream != null) {
            using(mutable reader = StreamReader(
                request.InputStream, request.ContentEncoding)) {

                def str = reader.ReadToEnd();
                def each_var = str.Split(array['&', ';'], StringSplitOptions.None);

                when(each_var.Length > 0) {
                    foreach(v in each_var) {
                        def s = v.Split(array['='], StringSplitOptions.None);

                        when(s.Length > 1) {
                            vars_out[s[0].ToString()] = s[1].ToString();
                        }
                    }
                }
            }
        }
    }

    static methodType(name: string): Method {
        match(name.ToUpper()) {
            | "OPTIONS" => OPTIONS
            | "GET" => GET
            | "HEAD" => HEAD
            | "POST" => POST
            | "PUT" => PUT
            | "DELETE" => DELETE
            | "TRACE" => TRACE
            | "CONNECT" => CONNECT
            | _ => INVALID_
        }
    }

    static methodName(mth: Method): string {
        match(mth) {
            | OPTIONS => "OPTIONS"
            | GET => "GET"
            | HEAD => "HEAD"
            | POST => "POST"
            | PUT => "PUT"
            | DELETE => "DELETE"
            | TRACE => "TRACE"
            | CONNECT => "CONNECT"
            | _ => "?"
        }
    }

    public extensionToMimeType(ext: string): string {
        def types = Configuration.MimeTypes;
        if(types.ContainsKey(ext)) {
            types[ext]
        } else {
            if(types.ContainsKey("_")) {
                types["_"]
            } else {
                "text/plain"
            }
        }
    }

    // stock request handlers (can be overridden by clients).

    public virtual internalServerErrorResponse(
        _context: Context, _request: Request, response: Response): void {

        response.append(
            "<html><body><h1>500 Internal Server Error</h1></body><html>");
        response.Status = (500, "Internal Server Error");
    }

    public virtual methodNotAllowedResponse(
        _context: Context, _request: Request, response: Response): void {

        response.append(
            "<html><body><h1>405 Method Not Allowed</h1></body><html>");
        response.Status = (405, "Method Not Allowed");
    }

    public virtual notFoundRespose(
        _context: Context, _request: Request, response: Response): void {

        response.append(
            "<html><body><h1>404 Not Found</h1></body><html>");
        response.Status = (404, "Not Found");
    }

    public virtual serveFileResponse(
        context: Context, request: Request, response: Response): void {

        using(def reader = BinaryReader(context.FileStream)) {
            mutable continue = true;

            while(continue) {
                def data = reader.ReadBytes(Configuration.FileChunkLength);
                response.appendBytes(data);
                continue = (data.Length == Configuration.FileChunkLength);
            }
        }
        response.ContentType = extensionToMimeType(request.Extension);
        response.Status = (200, "OK");
    }

    public virtual renderPageResponse(
        context: Context, request: Request, response: Response): void {

        def renderer = Renderers[request.Extension];
        def page = renderer.loadPage(context.FileStream);

        response.append(page.render(context.PageData));
        response.Status = (200, "OK");
    }
}


} // namespace httplib
