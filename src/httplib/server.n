using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Text.Encoding;
using System.Text.RegularExpressions;

using Nemerle.IO;
using Nemerle.Utility;

using YamlDeserializer = YamlDotNet.Serialization.Deserializer;


namespace httplib {

//------------------------------------------------------------------------------
// Server

public abstract class Server: IDisposable {

    public type Callback = Context * Request * Response -> void;
    type RouteMap = Dictionary[string, Route * Callback];
    type ContextMap = Dictionary[string, Route * PageData];

    type Method = HTTP;
    public static MethodCount = HTTP.COUNT_ :> int;

    [Accessor]
    static deserializer: YamlDeserializer = YamlDeserializer();

    [System.Flags]
    public enum State {
        | Neutral = 0x00
        | Running = 0x01
        | Closed = 0x02
    }

    [Accessor(Flags, flags = Protected)]
    [FlagAccessor(Running, flags = Protected | WantSetter)]
    [FlagAccessor(Closed, flags = Protected | WantSetter)]
    mutable state: State = State.Neutral;

    [Accessor(flags = Protected)]
    listener: HttpListener = HttpListener();

    [Accessor(flags = Protected)]
    configuration: ServerConfiguration;

    [Accessor(flags = Protected)]
    database: Database;

    public Routes[i: Method]: RouteMap {
        get { routes[i :> int] }
    }
    routes: array[RouteMap] = array(MethodCount);

    public Contexts[i: Method]: ContextMap {
        get { contexts[i :> int] }
    }
    contexts: array[ContextMap] = array(MethodCount);

    [Accessor(flags = Protected)]
    renderers: Dictionary[string, Renderer] = Dictionary();

    static protected loadConfiguration[T](path: string): T {
        using(reader = StreamReader(path)) {
            Deserializer.Deserialize.[T](reader);
        }
    }

    public this(path: string) {
        def config = loadConfiguration.[ServerConfiguration](path);
        this(config);
    }

    public this(config: ServerConfiguration) {

        configuration = config;
        def db = config.Database;

        when(db.Assembly != null && db.Typename != null) {
            database = Database.load(db.Assembly, db.Typename, db.Connection);
        }

        foreach(p in Configuration.Prefixes) {
            print("Adding \"$p\"...\n");
            Listener.Prefixes.Add(p);
        }

        foreach(x in Configuration.Renderers) {
            def r = Renderer.load(x.Value.Assembly, x.Value.Typename);
            when(r != null) {
                print("Registering $r for $(x.Key) files...\n");
                Renderers[x.Key] = r;
            }
        }

        for(mutable i = 0; i < MethodCount; i++) {
            routes[i] = Dictionary();
            contexts[i] = Dictionary();
        }

        // install default handlers for several methods...
        route(HTTP.INVALID_, ".*", internalServerErrorResponse);
        route(HTTP.OPTIONS, ".*", methodNotAllowedResponse);
        route(HTTP.TRACE, ".*", methodNotAllowedResponse);
        route(HTTP.CONNECT, ".*", methodNotAllowedResponse);

        Listener.AuthenticationSchemeSelectorDelegate = req => {
            def request = Request(req);
            handleAuthentication(request);
        };

        Listener.Start();
    }

    public Dispose(): void {
        shutdown();
    }

    protected override Finalize(): void {
        shutdown();
    }

    shutdown(): void {

        when(!Closed) {
            Listener.Close();
            Running = false;
            Closed = true;
        }
    }

    // route("/a/b/c", r => { })
    public route(method: Method, path: string, fn: Callback): void {

        def route = Route(path);
        def pattern = route.Pattern;
        print("route: $(methodName(method)) '$(path)' added $(fn)\n");
        Routes[method].Add(pattern, (route, fn));
    }

    public route(routes: list[(Method * string)], fn: Callback): void {
        foreach((method, path) in routes) {
            route(method, path, fn);
        }
    }

    public context(
        method: Method, path: string, data: PageData): void {

        def route = Route(path);
        def pattern = route.Pattern;
        print("context: $(methodName(method)) '$(path)' added $(data)\n");
        Contexts[method].Add(pattern, (route, data));
    }

    public context(contexts: list[(Method * string)], data: PageData): void {
        foreach((method, path) in contexts) {
            context(method, path, data);
        }
    }

    public update(): void {
        Running = true;
        def _ = Listener.BeginGetContext(listenerCallback, this);
    }

    findCallback(
        method_name: string, path: string, vars_out: ref HashTable): Callback {

        mutable result;
        exit: {
            def method = methodType(method_name);
            foreach(r in Routes[method]) {
                def (route, fn) = r.Value;
                def (ok, vars) = route.doMatch(path);

                when(ok) {
                    print("'$(path)' matches '$(route.Pattern)'...\n");
                    result = fn;
                    vars_out = vars;
                    exit();
                }
            }
        }
        result;
    }

    findContext(
        method_name: string, path: string): PageData {

        mutable result;
        exit: {
            def method = methodType(method_name);
            foreach(r in Contexts[method]) {
                def (route, data) = r.Value;
                def (ok, _) = route.doMatch(path);

                when(ok) {
                    result = data;
                    exit();
                }
            }
        }
        result;
    }

    public virtual renderPage(path: string, data: PageData = null): string {

        def ext = Path.GetExtension(path).Substring(1);
        print("ext = $ext...\n");
        using(stream = openLocalFile(path)) {

            def renderer = Renderers[ext];
            def page = renderer.loadPage(stream);

            page.render(data);

        }
    }

    /** Overridden by child classes */
    protected virtual internalServerError(_: Exception): void {
        //...
    }

    /** Overridden by child classes */
    protected virtual handleAuthentication(
        _request: Request): AuthenticationSchemes {

        AuthenticationSchemes.Anonymous;
    }

    /** Overridden by child classes */
    protected virtual callback(
        context: Context, request: Request, response: Response): void {
        // If the request.SearchedForFileStream is true, it means that the
        // request.FileStream was found by searching via the ImplicitExtensions
        if(request.FileStream != null) {
            if(request.SearchedForFileStream) {

                def renderer = Renderers[request.Extension];
                def page = renderer.loadPage(request.FileStream);

                response.append(page.render(context.PageData));

                response.Status = (200, "OK");
            } else {
                serveFileResponse(context, request, response);
            }
        } else {
            notFoundRespose(context, request, response);
        }
    }

    handleCallback(http_ctx: HttpListenerContext): void {
        mutable request, response, context = Context();
        try {
            request = Request(http_ctx.Request);
            response = Response(http_ctx.Response, Configuration.OutputLength);

            print("Requesting: \"/$(request.RawPath)\"...\n");

            // check for existing file under roots...
            def (fs, ext) = findLocalFileForRequest(request);
            request.FileStream = fs;

            when(!String.IsNullOrEmpty(ext)) {
                request.SearchedForFileStream = true;
                request.Extension = ext;
            }

            // find callback (and populate vars from route vars if any)
            mutable vars = HashTable();
            def cb = findCallback(
                request.HttpMethod, "/" + request.RawPath, ref vars);

            context.PageData = findContext(
                request.HttpMethod, "/" + request.RawPath);
            context.Vars = vars;

            // populate vars from body of POST...
            when(HTTP.POST == methodType(request.HttpMethod)) {
                processPostInputStream(http_ctx.Request, ref vars);
            }

            if(cb != null) {
                cb(context, request, response);
            } else {
                callback(context, request, response);
            }
        } catch {
            | ex => {
                internalServerError(ex);
                internalServerErrorResponse(context, request, response);
            }
        } finally {
            print($"Response Status: $(response.StatusCode) "
                $"$(response.StatusDescription)\n");
            // TODO: using() may be more appropriate here (if request/response
            //   gain Dispose() methods...)
            request.complete();
            response.complete();
        }
    }

    static listenerCallback(result: IAsyncResult): void {
        def server = result.AsyncState :> Server;
        def context = server.Listener.EndGetContext(result);

        server.handleCallback(context);
    }

    openLocalFile(path: string): FileStream {
        mutable result = null;
        exit: {
            foreach(root in Configuration.Roots) {
                def p = Path.Combine(root, path);
                def exists = File.Exists(p);
                def x = if(exists) { "yes" } else { "no" }

                print($"File exists: \"$p\"? $x\n");
                when(exists) {
                    result = FileStream(p, FileMode.Open);
                    exit();
                }
            }
        }
        result;
    }

    findLocalFileForRequest(request: Request): FileStream * string {
        mutable result = null, ext = null;
        if(!String.IsNullOrEmpty(request.Extension)) {
            result = openLocalFile(request.RawPath);

        } else {
            exit: {
                foreach(x in Configuration.Renderers) {
                    result = openLocalFile(request.RawPath + "." + x.Key);
                    when(result != null) {
                        ext = x.Key;
                        exit();
                    }
                }
            }
        }
        (result, ext);
    }

    processPostInputStream(
        request: HttpListenerRequest, vars_out: ref HashTable): void {

        when(request.InputStream != null) {
            using(mutable reader = StreamReader(
                request.InputStream, request.ContentEncoding)) {

                def str = reader.ReadToEnd();
                def each_var = str.Split(array['&', ';'], StringSplitOptions.None);

                when(each_var.Length > 0) {
                    foreach(v in each_var) {
                        def s = v.Split(array['='], StringSplitOptions.None);

                        when(s.Length > 1) {
                            vars_out[s[0].ToString()] = s[1].ToString();
                        }
                    }
                }
            }
        }
    }

    static methodType(name: string): Method {
        match(name.ToUpper()) {
            | "OPTIONS" => HTTP.OPTIONS
            | "GET" => HTTP.GET
            | "HEAD" => HTTP.HEAD
            | "POST" => HTTP.POST
            | "PUT" => HTTP.PUT
            | "DELETE" => HTTP.DELETE
            | "TRACE" => HTTP.TRACE
            | "CONNECT" => HTTP.CONNECT
            | _ => HTTP.INVALID_
        }
    }

    static methodName(mth: Method): string {
        match(mth) {
            | HTTP.OPTIONS => "OPTIONS"
            | HTTP.GET => "GET"
            | HTTP.HEAD => "HEAD"
            | HTTP.POST => "POST"
            | HTTP.PUT => "PUT"
            | HTTP.DELETE => "DELETE"
            | HTTP.TRACE => "TRACE"
            | HTTP.CONNECT => "CONNECT"
            | _ => "?"
        }
    }

    protected extensionToMimeType(ext: string): string {
        def types = Configuration.MimeTypes;
        if(types.ContainsKey(ext)) {
            types[ext]
        } else {
            if(types.ContainsKey("_")) {
                types["_"]
            } else {
                "text/plain"
            }
        }
    }

    // stock request handlers (can be overridden by clients).

    protected virtual internalServerErrorResponse(
        _ctx: Context, _req: Request, res: Response): void {

        res.append(
            "<html><body><h1>500 Internal Server Error</h1></body><html>");
        res.Status = (500, "Internal Server Error");
    }

    protected virtual methodNotAllowedResponse(
        _ctx: Context, _req: Request, res: Response): void {

        res.append(
            "<html><body><h1>405 Method Not Allowed</h1></body><html>");
        res.Status = (405, "Method Not Allowed");
    }

    protected virtual notFoundRespose(
        _context: Context, _request: Request, response: Response): void {

        response.append(
            "<html><body><h1>404 Not Found</h1></body><html>");
        response.Status = (404, "Not Found");
    }

    protected virtual serveFileResponse(
        _context: Context, request: Request, response: Response): void {

        using(def reader = BinaryReader(request.FileStream)) {
            mutable continue = true;

            while(continue) {
                def data = reader.ReadBytes(Configuration.FileChunkLength);
                response.appendBytes(data);
                continue = (data.Length == Configuration.FileChunkLength);
            }
        }
        response.ContentType = extensionToMimeType(request.Extension);
        response.Status = (200, "OK");
    }
}


} // namespace httplib
