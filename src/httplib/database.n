using System;
using System.Data;
using System.Reflection;

using Nemerle.Utility;


namespace httplib {

[HasLogging]
public abstract class Database: IDisposable  {

    [Accessor(flags = WantSetter)]
    protected mutable connection: IDbConnection = null;

    public virtual Initialized: bool {
        get { Connection != null }
    }

    public this(connection: string = null) {
        when(connection != null) {
            initialize(connection);
        }
        when(Connection != null) {
            open();
        }
    }

    public Dispose(): void {
        shutdown();
    }

    protected override Finalize(): void {
        shutdown();
    }

    shutdown(): void {
        close();
        Connection.Dispose();
    }

    public abstract initialize(connection: string): void;

    public virtual open(): void {
        Connection.Open();
    }

    public virtual close(): void {
        Connection.Close();
    }

    public withTransaction(
        lambda: Database -> void,
        handle: Exception -> void = null): void {

        mutable transaction = null;
        try {
            transaction = Connection.BeginTransaction();
            _ = lambda(this);
            transaction.Commit();
        } catch {
            | ex => {
                Log.w("Rolling back...");
                transaction.Rollback();
                when(handle != null) {
                    handle(ex);
                }
            }
        }
    }

    public virtual createCommand(query: string = null): Command {
        mutable result = Command(Connection.CreateCommand());
        when(query != null) {
            result.Query = query;
        }
        result;
    }

    /** Load a DB by reflection, given a DLL and type name. */
    public static load(
        path: string, name: string, param: string = null): Database {

        def assembly = Assembly.LoadFrom(path);
        def type = assembly.GetType(name);

        Activator.CreateInstance(type, param) :> Database;
    }
}


public class Command {

    [Accessor]
    protected mutable command: IDbCommand = null;

    public virtual Query: string {
        get { Command.CommandText; }
        set { Command.CommandText = value; }
    }

    public virtual Parameters: IDataParameterCollection {
        get { Command.Parameters; }
    }

    public this(c: IDbCommand) {
        command = c;
    }

    public virtual createParameter(
        name: string = null, value: object = null): Parameter {

        mutable result = Parameter(Command.CreateParameter());

        when(name != null) {
            result.Name = name;
        }
        when(value != null) {
            result.Value = value;
        }

        result;
    }

    /** For use with Nemerle.Extensions <- operator...
     *  db.createCommand("...@X...") <- [ "@X" = x, ... ]; */
    public virtual Add[T](name: string, value: T): void {
        addParameter(name, value);
    }

    public virtual addParameter(param: Parameter): void {
        _ = Parameters.Add(param.Parameter);
    }

    public virtual addParameter(name: string, value: object): void {
        addParameter(createParameter(name, value));
    }

    public virtual executeNonQuery(): int {
        Command.ExecuteNonQuery();
    }

    public virtual executeReader(): DataReader {
        DataReader(Command.ExecuteReader(), this);
    }

    public virtual executeScalar(): object {
        Command.ExecuteScalar();
    }
}


public class Parameter {

    [Accessor]
    protected mutable parameter: IDbDataParameter = null;

    public virtual Name: string {
        get { Parameter.ParameterName; }
        set { Parameter.ParameterName = value; }
    }

    public virtual Value: object {
        get { Parameter.Value; }
        set { Parameter.Value = value; }
    }

    public this(p: IDbDataParameter) {
        parameter = p;
    }
}


[HasLogging]
public class DataReader: IDisposable {

    [Accessor]
    protected mutable reader: IDataReader = null;
    protected mutable command: Command = null;

    public this(r: IDataReader, c: Command) {
        reader = r;
        command = c;
    }

    public Dispose(): void {
        reader.Dispose();
    }

    public enumerate(lambda: void -> void): void {
        lock(command) {
            while(reader.Read()) {
                lambda();
            }
            reader.Close();
        }
    }

    public enumerate(lambda: int -> void): int {
        mutable i = 0;
        lock(command) {
            while(reader.Read()) {
                lambda(i);
                i++;
            }
            reader.Close();
        }
        i;
    }

    public getValue[T](field: string, default: T): T {
        def ordinal = reader.GetOrdinal(field);
        getValue.[T](ordinal, default);
    }

    public getValue[T](field: int, default: T): T {
        if(reader.IsDBNull(field)) {
            default;
        } else {
            unchecked reader.GetValue(field) :> T;
        }
    }

    public getValue[T](field: string): T {
        def ordinal = reader.GetOrdinal(field);
        getValue.[T](ordinal);
    }

    public getValue[T](field: int): T {
        if(reader.IsDBNull(field)) {
            default(T);
        } else {
            unchecked reader.GetValue(field) :> T;
        }
    }
}


} // namespace httplib
